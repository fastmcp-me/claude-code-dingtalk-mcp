#!/usr/bin/env node

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
import { DingTalkClient, DingTalkConfig } from './dingtalk.js';
import { execSync } from 'child_process';

class DingTalkMCPServer {
  private server: Server;
  private dingTalkClient: DingTalkClient | null = null;

  constructor() {
    this.server = new Server(
      {
        name: 'dingtalk-mcp-server',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupHandlers();
    this.initializeFromEnv();
  }

  private getGitUsername(): string {
    try {
      const username = execSync('git config --get user.name', { encoding: 'utf8' }).trim();
      return username || 'Unknown User';
    } catch (error) {
      return 'Unknown User';
    }
  }

  private initializeFromEnv() {
    const webhook = process.env.DINGTALK_WEBHOOK;
    const secret = process.env.DINGTALK_SECRET;
    const keywords = process.env.DINGTALK_KEYWORDS;

    if (webhook) {
      const config: DingTalkConfig = {
        webhook,
        secret,
        keywords: keywords ? keywords.split(',').map(k => k.trim()) : undefined
      };
      this.dingTalkClient = new DingTalkClient(config);
      console.error('‚úÖ DingTalk client initialized from environment variables');
    }
  }

  private setupHandlers() {
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {
            name: 'dingtalk_configure',
            description: 'Configure DingTalk webhook settings',
            inputSchema: {
              type: 'object',
              properties: {
                webhook: {
                  type: 'string',
                  description: 'DingTalk webhook URL with access token',
                },
                secret: {
                  type: 'string',
                  description: 'Optional secret for signature verification',
                },
                keywords: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Optional keywords for security validation',
                },
              },
              required: ['webhook'],
            },
          },
          {
            name: 'dingtalk_send_text',
            description: 'Send a text message to DingTalk group',
            inputSchema: {
              type: 'object',
              properties: {
                content: {
                  type: 'string',
                  description: 'Text content to send',
                },
                atAll: {
                  type: 'boolean',
                  description: 'Whether to @all members',
                  default: false,
                },
              },
              required: ['content'],
            },
          },
          {
            name: 'dingtalk_send_markdown',
            description: 'Send a markdown message to DingTalk group',
            inputSchema: {
              type: 'object',
              properties: {
                title: {
                  type: 'string',
                  description: 'Message title',
                },
                text: {
                  type: 'string',
                  description: 'Markdown formatted text content',
                },
                atAll: {
                  type: 'boolean',
                  description: 'Whether to @all members',
                  default: false,
                },
              },
              required: ['title', 'text'],
            },
          },
          {
            name: 'dingtalk_send_link',
            description: 'Send a link message to DingTalk group',
            inputSchema: {
              type: 'object',
              properties: {
                title: {
                  type: 'string',
                  description: 'Link title',
                },
                text: {
                  type: 'string',
                  description: 'Link description text',
                },
                messageUrl: {
                  type: 'string',
                  description: 'Target URL',
                },
                picUrl: {
                  type: 'string',
                  description: 'Optional image URL',
                },
              },
              required: ['title', 'text', 'messageUrl'],
            },
          },
          {
            name: 'dingtalk_notify_session_end',
            description: 'Send a session completion notification with automatic stats',
            inputSchema: {
              type: 'object',
              properties: {
                sessionType: {
                  type: 'string',
                  description: 'Type of session (e.g., "ÂºÄÂèëÂçèÂä©", "‰ª£Á†ÅÂÆ°Êü•", "ÈóÆÈ¢òËß£ÂÜ≥")',
                  default: 'ÂºÄÂèëÂçèÂä©'
                },
                duration: {
                  type: 'string',
                  description: 'Session duration (e.g., "30ÂàÜÈíü", "1Â∞èÊó∂20ÂàÜ")',
                },
                mainTasks: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'List of main tasks completed in this session',
                },
                summary: {
                  type: 'string',
                  description: 'Brief summary of the session',
                  default: '‰ºöËØùÂ∑≤ÂÆåÊàê'
                },
                filesCount: {
                  type: 'number',
                  description: 'Number of files modified/created',
                  default: 0
                },
                toolsUsed: {
                  type: 'number', 
                  description: 'Number of tools/commands used',
                  default: 0
                },
                atAll: {
                  type: 'boolean',
                  description: 'Whether to @all members',
                  default: false
                }
              },
              required: []
            },
          },
        ],
      };
    });

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        switch (name) {
          case 'dingtalk_configure':
            return await this.handleConfigure(args as unknown as DingTalkConfig);

          case 'dingtalk_send_text':
            return await this.handleSendText(args as unknown as { content: string; atAll?: boolean });

          case 'dingtalk_send_markdown':
            return await this.handleSendMarkdown(args as unknown as { title: string; text: string; atAll?: boolean });

          case 'dingtalk_send_link':
            return await this.handleSendLink(args as unknown as { title: string; text: string; messageUrl: string; picUrl?: string });

          case 'dingtalk_notify_session_end':
            return await this.handleNotifySessionEnd(args as unknown as {
              sessionType?: string;
              duration?: string;
              mainTasks?: string[];
              summary?: string;
              filesCount?: number;
              toolsUsed?: number;
              atAll?: boolean;
            });

          case 'dingtalk_notify_task_complete':
            return await this.handleNotifyTaskComplete(args as unknown as {
              taskName: string;
              status: 'success' | 'failed' | 'warning';
              details?: string;
              duration?: string;
              atAll?: boolean;
            });

          default:
            throw new Error(`Unknown tool: ${name}`);
        }
      } catch (error) {
        return {
          content: [
            {
              type: 'text',
              text: `Error: ${error instanceof Error ? error.message : String(error)}`,
            },
          ],
        };
      }
    });
  }

  private async handleConfigure(config: DingTalkConfig) {
    this.dingTalkClient = new DingTalkClient(config);
    return {
      content: [
        {
          type: 'text',
          text: '‚úÖ DingTalk client configured successfully',
        },
      ],
    };
  }

  private async handleSendText(args: { content: string; atAll?: boolean }) {
    if (!this.dingTalkClient) {
      throw new Error('DingTalk client not configured. Use dingtalk_configure first or set environment variables (DINGTALK_WEBHOOK, DINGTALK_SECRET).');
    }

    const gitUsername = this.getGitUsername();
    const contentWithUser = `${args.content}\n\n---\nüë§ ÂèëÈÄÅËÄÖ: ${gitUsername}`;

    const success = await this.dingTalkClient.sendText(contentWithUser, args.atAll);
    return {
      content: [
        {
          type: 'text',
          text: success 
            ? '‚úÖ Text message sent successfully' 
            : '‚ùå Failed to send text message',
        },
      ],
    };
  }

  private async handleSendMarkdown(args: { title: string; text: string; atAll?: boolean }) {
    if (!this.dingTalkClient) {
      throw new Error('DingTalk client not configured. Use dingtalk_configure first or set environment variables (DINGTALK_WEBHOOK, DINGTALK_SECRET).');
    }

    const gitUsername = this.getGitUsername();
    const textWithUser = `${args.text}\n\n---\nüë§ **ÂèëÈÄÅËÄÖ:** ${gitUsername}`;

    const success = await this.dingTalkClient.sendMarkdown(args.title, textWithUser, args.atAll);
    return {
      content: [
        {
          type: 'text',
          text: success 
            ? '‚úÖ Markdown message sent successfully' 
            : '‚ùå Failed to send markdown message',
        },
      ],
    };
  }

  private async handleSendLink(args: { title: string; text: string; messageUrl: string; picUrl?: string }) {
    if (!this.dingTalkClient) {
      throw new Error('DingTalk client not configured. Use dingtalk_configure first or set environment variables (DINGTALK_WEBHOOK, DINGTALK_SECRET).');
    }

    const success = await this.dingTalkClient.sendLink(args.title, args.text, args.messageUrl, args.picUrl);
    return {
      content: [
        {
          type: 'text',
          text: success 
            ? '‚úÖ Link message sent successfully' 
            : '‚ùå Failed to send link message',
        },
      ],
    };
  }

  private async handleNotifySessionEnd(args: {
    sessionType?: string;
    duration?: string;
    mainTasks?: string[];
    summary?: string;
    filesCount?: number;
    toolsUsed?: number;
    atAll?: boolean;
  }) {
    if (!this.dingTalkClient) {
      throw new Error('DingTalk client not configured. Use dingtalk_configure first or set environment variables (DINGTALK_WEBHOOK, DINGTALK_SECRET).');
    }

    const sessionType = args.sessionType || 'ÂºÄÂèëÂçèÂä©';
    const duration = args.duration || 'ÂàöÂàöÂÆåÊàê';
    const mainTasks = args.mainTasks || [];
    const summary = args.summary || '‰ºöËØùÂ∑≤ÂÆåÊàê';
    const filesCount = args.filesCount || 0;
    const toolsUsed = args.toolsUsed || 0;

    const now = new Date();
    const gitUsername = this.getGitUsername();
    const title = `ü§ñ Claude Code ${sessionType}ÂÆåÊàê`;
    
    let content = `## ü§ñ Claude Code ${sessionType}ÂÆåÊàê

**ÂÆåÊàêÊó∂Èó¥Ôºö** ${now.toLocaleString('zh-CN')}
**‰ºöËØùÊó∂ÈïøÔºö** ${duration}
**Êìç‰ΩúËÄÖÔºö** ${gitUsername}

### üìã Êú¨Ê¨°‰ºöËØù
${summary}`;

    if (mainTasks.length > 0) {
      content += `

### ‚úÖ ‰∏ªË¶Å‰ªªÂä°
${mainTasks.map(task => `- ${task.trim()}`).join('\n')}`;
    }

    content += `

### üìä Êìç‰ΩúÁªüËÆ°
- **Êñá‰ª∂Êìç‰ΩúÔºö** ${filesCount} ‰∏™
- **Â∑•ÂÖ∑‰ΩøÁî®Ôºö** ${toolsUsed} Ê¨°

---
*Claude Code Ëá™Âä®ÈÄöÁü• | ${now.toLocaleDateString('zh-CN')}*`;

    const success = await this.dingTalkClient.sendMarkdown(title, content, args.atAll);

    return {
      content: [
        {
          type: 'text',
          text: success 
            ? '‚úÖ Session completion notification sent successfully' 
            : '‚ùå Failed to send session completion notification',
        },
      ],
    };
  }

  private async handleNotifyTaskComplete(args: {
    taskName: string;
    status: 'success' | 'failed' | 'warning';
    details?: string;
    duration?: string;
    atAll?: boolean;
  }) {
    if (!this.dingTalkClient) {
      throw new Error('DingTalk client not configured. Use dingtalk_configure first or set environment variables (DINGTALK_WEBHOOK, DINGTALK_SECRET).');
    }

    const statusEmoji = {
      success: '‚úÖ',
      failed: '‚ùå',
      warning: '‚ö†Ô∏è'
    };

    const statusText = {
      success: '‰ªªÂä°ÂÆåÊàê',
      failed: '‰ªªÂä°Â§±Ë¥•',
      warning: '‰ªªÂä°Ë≠¶Âëä'
    };

    const timestamp = new Date().toLocaleString('zh-CN');
    const gitUsername = this.getGitUsername();
    
    let markdownText = `## ${statusEmoji[args.status]} ${statusText[args.status]}

**‰ªªÂä°ÂêçÁß∞Ôºö** ${args.taskName}
**Áä∂ÊÄÅÔºö** ${statusText[args.status]}
**Êó∂Èó¥Ôºö** ${timestamp}
**Êìç‰ΩúËÄÖÔºö** ${gitUsername}`;

    if (args.duration) {
      markdownText += `\n**ËÄóÊó∂Ôºö** ${args.duration}`;
    }

    if (args.details) {
      markdownText += `\n\n**ËØ¶ÊÉÖÔºö**\n${args.details}`;
    }

    markdownText += '\n\n---\n*Êù•Ëá™ Claude Code MCP Server*';

    const success = await this.dingTalkClient.sendMarkdown(
      `${statusEmoji[args.status]} ${args.taskName} - ${statusText[args.status]}`,
      markdownText,
      args.atAll
    );

    return {
      content: [
        {
          type: 'text',
          text: success 
            ? '‚úÖ Task completion notification sent successfully' 
            : '‚ùå Failed to send task completion notification',
        },
      ],
    };
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('DingTalk MCP server running on stdio');
  }
}

const server = new DingTalkMCPServer();
server.run().catch(console.error);